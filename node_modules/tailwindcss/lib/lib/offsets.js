// @ts-check
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Offsets", {
    enumerable: true,
    get: function() {
        return Offsets;
    }
});
const _bigSign = /*#__PURE__*/ _interop_require_default(require("../util/bigSign"));
const _remapbitfield = require("./remap-bitfield.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class Offsets {
    constructor(){
        /**
     * Offsets for the next rule in a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.offsets = {
            defaults: 0n,
            base: 0n,
            components: 0n,
            utilities: 0n,
            variants: 0n,
            user: 0n
        };
        /**
     * Positions for a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.layerPositions = {
            defaults: 0n,
            base: 1n,
            components: 2n,
            utilities: 3n,
            // There isn't technically a "user" layer, but we need to give it a position
            // Because it's used for ordering user-css from @apply
            user: 4n,
            variants: 5n
        };
        /**
     * The total number of functions currently registered across all variants (including arbitrary variants)
     *
     * @type {bigint}
     */ this.reservedVariantBits = 0n;
        /**
     * Positions for a given variant
     *
     * @type {Map<string, bigint>}
     */ this.variantOffsets = new Map();
    }
    /**
   * @param {Layer} layer
   * @returns {RuleOffset}
   */ create(layer) {
        return {
            layer,
            parentLayer: layer,
            arbitrary: 0n,
            variants: 0n,
            parallelIndex: 0n,
            index: this.offsets[layer]++,
            propertyOffset: 0n,
            property: "",
            options: []
        };
    }
    /**
   * @param {string} name
   * @returns {RuleOffset}
   */ arbitraryProperty(name) {
        return {
            ...this.create("utilities"),
            arbitrary: 1n,
            property: name
        };
    }
    /**
   * Get the offset for a variant
   *
   * @param {string} variant
   * @param {number} index
   * @returns {RuleOffset}
   */ forVariant(variant, index = 0) {
        let offset = this.variantOffsets.get(variant);
        if (offset === undefined) {
            throw new Error(`Cannot find offset for unknown variant ${variant}`);
        }
        return {
            ...this.create("variants"),
            variants: offset << BigInt(index)
        };
    }
    /**
   * @param {RuleOffset} rule
   * @param {RuleOffset} variant
   * @param {VariantOption} options
   * @returns {RuleOffset}
   */ applyVariantOffset(rule, variant, options) {
        options.variant = variant.variants;
        return {
            ...rule,
            layer: "variants",
            parentLayer: rule.layer === "variants" ? rule.parentLayer : rule.layer,
            variants: rule.variants | variant.variants,
            options: options.sort ? [].concat(options, rule.options) : rule.options,
            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
            // We'll take the max of all the parallel indexes for now.
            // @ts-ignore
            parallelIndex: max([
                rule.parallelIndex,
                variant.parallelIndex
            ])
        };
    }
    /**
   * @param {RuleOffset} offset
   * @param {number} parallelIndex
   * @returns {RuleOffset}
   */ applyParallelOffset(offset, parallelIndex) {
        return {
            ...offset,
            parallelIndex: BigInt(parallelIndex)
        };
    }
    /**
   * Each variant gets 1 bit per function / rule registered.
   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
   * Additionally, every unique group of variants is grouped together in the stylesheet.
   *
   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
   *
   * @param {string[]} variants
   * @param {(name: string) => number} getLength
   */ recordVariants(variants, getLength) {
        for (let variant of variants){
            this.recordVariant(variant, getLength(variant));
        }
    }
    /**
   * The same as `recordVariants` but for a single arbitrary variant at runtime.
   * @param {string} variant
   * @param {number} fnCount
   *
   * @returns {RuleOffset} The highest offset for this variant
   */ recordVariant(variant, fnCount = 1) {
        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
        // Ensure space is reserved for each "function" in the parallel variant
        // by offsetting the next variant by the number of parallel variants
        // in the one we just added.
        // Single functions that return parallel variants are NOT handled separately here
        // They're offset by 1 (or the number of functions) as usual
        // And each rule returned is tracked separately since the functions are evaluated lazily.
        // @see `RuleOffset.parallelIndex`
        this.reservedVariantBits += BigInt(fnCount);
        return {
            ...this.create("variants"),
            variants: this.variantOffsets.get(variant)
        };
    }
    /**
   * @param {RuleOffset} a
   * @param {RuleOffset} b
   * @returns {bigint}
   */ compare(a, b) {
        // Sort layers together
        if (a.layer !== b.layer) {
            return this.layerPositions[a.layer] - this.layerPositions[b.layer];
        }
        // When sorting the `variants` layer, we need to sort based on the parent layer as well within
        // this variants layer.
        if (a.parentLayer !== b.parentLayer) {
            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];
        }
        // Sort based on the sorting function
        for (let aOptions of a.options){
            for (let bOptions of b.options){
                if (aOptions.id !== bOptions.id) continue;
                if (!aOptions.sort || !bOptions.sort) continue;
                var _max;
                let maxFnVariant = (_max = max([
                    aOptions.variant,
                    bOptions.variant
                ])) !== null && _max !== void 0 ? _max : 0n;
                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit
                let mask = ~(maxFnVariant | maxFnVariant - 1n);
                let aVariantsAfterFn = a.variants & mask;
                let bVariantsAfterFn = b.variants & mask;
                // If the variants the same, we _can_ sort them
                if (aVariantsAfterFn !== bVariantsAfterFn) {
                    continue;
                }
                let result = aOptions.sort({
                    value: aOptions.value,
                    modifier: aOptions.modifier
                }, {
                    value: bOptions.value,
                    modifier: bOptions.modifier
                });
                if (result !== 0) return result;
            }
        }
        // Sort variants in the order they were registered
        if (a.variants !== b.variants) {
            return a.variants - b.variants;
        }
        // Make sure each rule returned by a parallel variant is sorted in ascending order
        if (a.parallelIndex !== b.parallelIndex) {
            return a.parallelIndex - b.parallelIndex;
        }
        // Always sort arbitrary properties after other utilities
        if (a.arbitrary !== b.arbitrary) {
            return a.arbitrary - b.arbitrary;
        }
        // Always sort arbitrary properties alphabetically
        if (a.propertyOffset !== b.propertyOffset) {
            return a.propertyOffset - b.propertyOffset;
        }
        // Sort utilities, components, etcâ€¦ in the order they were registered
        return a.index - b.index;
    }
    /**
   * Arbitrary variants are recorded in the order they're encountered.
   * This means that the order is not stable bet tÀH‹ºH   H‹\$8H‹l$@H‹t$HHƒÄ _é¯E  ÌÌÌH‰\$H‰l$H‰t$ WHƒì H‹ùH‹	H‹Y€{ uGL‹CH‹×H‹Ïè‘  H‹ëH‹H‹M@H…Ét
è W  Hƒe@ HM è/+  ºH   H‹ÍèJE  €{ t¼H‹ºH   H‹\$8H‹l$@H‹t$HHƒÄ _é#E  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH…ÉHAA¸   IDÀH‹Èé‹  ÌÌÌÌÌÌÌH…ÉHAA¸   IDÀH‹ÈéŸ  ÌÌÌÌÌÌÌH…ÉHAA¹   IDÁH‹ÈéÃ  ÌÌÌÌÌÌÌHAğH÷ÙHÉH#ÈH‹H‹@Hÿ%%f  ÌÌÌÌÌHAğH÷ÙHÉH#ÈH‹H‹@Hÿ%f  ÌÌÌÌÌH…ÉHAA¹   IDÁH‹Èé¿  ÌÌÌÌÌÌÌH‰\$WHƒì Hƒ" HY`H…É¸p   H‹úHDØH‹H…ÛtH‹H‹ËH‹@ÿ§e  H‰3ÀH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌH…ÉHAA¸   IDÀH‹Èé{  ÌÌÌÌÌÌÌH…ÉHAA¸   IDÀH‹Èé  ÌÌÌÌÌÌÌH…ÉHAA¹   IDÁH‹Èé³  ÌÌÌÌÌÌÌHAøH÷ÙHÉH#ÈH‹H‹@Hÿ%e  ÌÌÌÌÌHAøH÷ÙHÉH#ÈH‹H‹@Hÿ%õd  ÌÌÌÌÌH…ÉHAA¹   IDÁH‹Èé¯  ÌÌÌÌÌÌÌL‹ÜHƒìXH‹jÁ  H3ÄH‰D$@I‰SàM‰CØM‰KĞHA0º8   H…ÉHDÂMCĞISØIKàH‹ ÿ‰d  3Àë‹D$ H‹L$@H3Ìè3B  HƒÄXÃÌÌÌÌÌÌÌÌÌÌÌÌÌL‹ÜHƒìHH‹úÀ  H3ÄH‰D$8I‰SèM‰CàHA(º0   H…ÉHDÂISàIKèH‹ ÿ!d  3Àë‹D$ H‹L$8H3ÌèËA  HƒÄHÃÌÌÌÌÌ@SVWATAUAVAWHƒìPM‹àH‹ÂL‹é3ÛI‰L¹   ¹˜   M…íLDù3ÒH‹Èè
T  H‹ĞHL$(èÇ	  I‹7H‹~L‹öëHW LD$(èÀ
  „ÀtH‹ëH‹÷H‹?8_tÜI;ötLF HT$(è—
  „ÀtI‹öHL$(è­'  I;7t'IEP¹X   M…íHDÁLF@HT$ H‹èöéÿÿH‹\$ I‰$3Àë‹D$ HƒÄPA_A^A]A\_^[ÃÌÌÌÌÌÌÌÌ@SVWHƒìPH‹©¿  H3ÄH‰D$@I‹ğH‰T$8Iƒ  HAøH÷ÙHÛH#ØHƒd$0 H‹KpH‰L$ H…ÉtH‹H‹@ÿ¿b  HT$0HL$ è&  @ŠøHƒ|$  tHL$ è¤ÿÿHƒ|$0 tHL$0èò£ÿÿ@„ÿtRH‹[pH‰\$(H…ÛtH‹H‹ËH‹@ÿbb  Hƒd$0 H‹LD$0H‹T$8H‹ËH‹€˜   ÿ>b  …ÀˆŠ   H‹\$0ëWH‹C@H…Àt'HT$8HL$ ÿb  H‹Hƒ  Hƒ|$  t9HL$ ë,LD$8H‹ÓHL$(H‹CPÿça  H‹Hƒ  Hƒ|$( tHL$(è9£ÿÿH‰3Àë‹D$ H‹L$@H3Ìèt?  HƒÄP_^[Ã‹ÈèD¯ÿÿÌÌÌH‰\$WHƒì H‹ÚHƒ" HA º(   H…ÉHDÂHL$0H‹ ÿqa  H‹8Hƒ  Hƒ|$0 tHL$0èÃ¢ÿÿH‰;3Àë‹D$0H‹\$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì@H‹ÚWÀHAøH÷ÙHÉH#ÈHT$0è.ñÿÿWÀD$ HL$ H;ÈtH‹Hƒ  H‰L$ ‹@‰D$(D$ óH‹L$0H…ÉtèÛP  3Àë‹D$PHƒÄ@[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÚHƒ" HAPºX   H…ÉHDÂL€   ºˆ   LDÂHT$0H‹èúãÿÿH‹D$0H‰3Àë‹D$0HƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÚHƒ" HAPºX   H…ÉHDÂLAxº€   LDÂHT$0H‹èãÿÿH‹D$0H‰3Àë‹D$0HƒÄ [ÃÌÌH…ÉH³   A¸»   IDÀŠ ˆ3ÀÃÌÌÌÌÌH…ÉH±   A¸¹   IDÀŠ ˆ3ÀÃÌÌÌÌÌH…ÉHA0A¸8   IDÀHƒ8 •Àˆ3ÀÃÌÌÌH…ÉHA A¸(   IDÀHƒ8 •Àˆ3ÀÃÌÌÌH…ÉHA(A¸0   IDÀHƒ8 •Àˆ3ÀÃÌÌÌH…ÉH°   A¸¸   IDÀŠ ˆ3ÀÃÌÌÌÌÌ@SHƒì H‹ÚHƒ" HAøH÷ÙHÉH#ÈHT$0èàîÿÿH‹Hƒ  H‰H‹L$0H…ÉtèO  3Àë‹D$0HƒÄ [ÃÌÌÌ@SHƒì H‹ÚHƒ" HAPºX   H…ÉHDÂLApºx   LDÂHT$0H‹èuåÿÿH‹D$0H‰3Àë‹D$0HƒÄ [ÃÌÌH‰\$WHƒì Hƒ" HY`H…É¸h   H‹úHDØH‹H…ÛtH‹H‹ËH‹@ÿg^  H‰3ÀH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌHAèÃÌÌÌÌÌÌÌÌÌÌÌHùv  Ç   H‰BH‹ÂÃÌÌÌÌÌÌÌÌÌÌÌHƒÁèHQH÷ÙHÀH#ÂÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‹HƒÁèH;Òv  uH‹BH;Ív  tIH‹H;yv  uH‹BH;tv  uHAH÷ÙHÉH#Èë!H‹H;av  uH‹BH;\v  uHAëÖ3ÉH‹ÁÃÌÌÌÌÌÌH‰\$WHƒì HYH‹CëHxÿğH±{t#H…ÀyïH ƒÏÿğÁyƒïuH‹H‹@ÿM]  …ÿu!GD‹ÀL‡CH…ÛtL‹‹ĞH‹ËI‹@ÿ(]  H‹\$0‹ÇHƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌH‹Q H…ÒxLBH‹ÂğL±A H‹ĞtH…ÀyéA¸   ğDÁDAÿÀA‹ÀÃÌÌÌÌÌÌÌÌÌÌÌÌHƒÁéŸ  ÌÌÌÌÌÌÌHƒì(èË  H‹ĞHL$8èÚÿÿèK®ÿÿ‹D$8HƒÄ(ÃÌÌÌÌÌÌÌÌÌHƒì8è›  H‹ĞHL$ èíÙÿÿè®ÿÿ‹D$ HƒÄ8ÃÌÌÌÌÌÌÌÌÌHƒì8H‹ÁI‹ÈèÕÿÿH‹Èè\  H‹ĞHL$ è®ÙÿÿèÜ­ÿÿ‹D$ HƒÄ8ÃÌÌÌÌÌÌÌÌÌÌHƒì(H‹ÁH‹Êè•ÿÿH‹Èè  H‹ĞHL$@ènÙÿÿèœ­ÿÿ‹D$@HƒÄ(ÃÌÌÌÌÌÌÌÌÌÌ@SHƒì@H‹ÚWÀHAğH÷ÙHÉH#ÈHT$0èâæÿÿWÀD$ HL$ H;ÈtH‹Hƒ  H‰L$ ‹@‰D$(D$ óH‹L$0H…Étè‹K  3Àë‹D$PHƒÄ@[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(èk  H‹ĞHL$@è½Øÿÿèë¬ÿÿ‹D$@HƒÄ(ÃÌÌÌÌÌÌÌÌÌ@SHƒì0H‹Ë·  H3ÄH‰D$(H‹ÚH‹ÁHƒ" HƒÁº   H…ÀHDÊHƒd$  HT$ H‹	è9K  …Àx$H‹D$ H‰3Àë‹D$ H‹L$(H3ÌèŒ8  HƒÄ0[Ã‹Èè^¨ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì0H‹K·  H3ÄH‰D$(H‰T$ LD$ Hƒd$  HTo  H‹Úº    è¤J  …ÀxH‹L$ H‹ÃH‰H‹L$(H3Ìè8  HƒÄ0[Ã‹Èèî§ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌHÙr  Ç   H‰BH‹ÂÃÌÌÌÌÌÌÌÌÌÌÌH‹H;¶r  uH‹BH;±r  uHAH÷ÙHÉH#Èë3ÉH‹ÁÃÌÌH‰\$H‰t$WHƒì 3öHÇA   L‹ÊH‰qf‰1HƒÊÿH‹ùHÿÂfA94QuöHƒúwHH‰QL‹ÃI‹ÑèêJ  f‰4;ëèÈ  H‹\$0H‹ÇH‹t$8HƒÄ _ÃÌ@SVWHƒì@H‹¶  H3ÄH‰D$0¸   H‹ú3ÛHT$ H…ÉI‹ğHDÈH‹H‹@ÿGY  ‹D$ …Àt4‹È‰HÁáèeI  H‰H…Àu» €ëD‹D$ H‹ÈH‹T$(IÁàèTJ  ë‰H‰‹ÃH‹L$0H3Ìè·6  HƒÄ@_^[ÃÌÌÌHQğH÷ÙHÀH#ÂÃÌÌH‰\$IƒxI‹XrM‹ HƒzL‹RrH‹I;ÚM‹ÚLBÛ3ÀM…Ût5·
E·fA;Ér%I+ĞfA;Éw-IƒûtIƒÀIÿËB·E·fA;ÉsâƒÈÿ…ÀuL;ÓsƒÈÿë¸   ëë3ÀL;Ó—ÀH‹\$ÁèÃÌÌÌHƒì(H‹Hƒ! H‹H‹ÊH‹@ÿ1X  HƒÄ(ÃÌÌÌH‰\$H‰t$H‰|$AVHƒì ¸   H‹Ù3ÿM‹ğH…ÉH‹òHDÈH‹H‹@(ÿïW  I‰H…Àt-H‹SH…Òˆw  HJH‹ÂğH±KH‹Ğ„l  H…ÀyåéW  H‹H;8m  uMH‹FH;3m  u@H‹H‹ËH‹@ÿ‘W  I‰H‹SH…Òˆ  HJH‹ÂğH±KH‹Ğ„  H…Àyåéş   H‹H;wk  uXH‹FH;rk  uKH‹H‹ËH‹@ÿ8W  HÁÁ  ¹    H‹Øèx5  H…ÀtH‹ÓH‹ÈèÔœÿÿH‹øI‰>H÷ßÀ÷Ğ% €éê   H‹H;Sm  uBH‹FH;Nm  u5H‹H‹ËH‹@0ÿÔV  I‰H‹SH…ÒxeHJH‹ÂğH±KH‹Ğt^H…ÀyéëLH‹H;5m  uOH‹FH;0m  uBH‹H‹ËH‹@ÿ†V  I‰H‹SH…ÒxHJH‹ÂğH±KH‹ĞtH…Àyé¸   ğÁD3ÀëAH‹H;ºl  u H‹FH;µl  uH‹Ëè“–ÿÿI‰H÷ØéÿÿÿH‹M‹ÆH‹ÖH‹ËH‹ ÿV  H‹\$0H‹t$8H‹|$@HƒÄ A^ÃÌ@SHƒì H‹Ú¸   